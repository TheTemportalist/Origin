// For those who want the bleeding edge
buildscript {
	repositories {
		jcenter()
		maven {
			name = "forge"
			url = "http://files.minecraftforge.net/maven"
		}
		/*
		maven {
			// for cursegradle
			url = "https://plugins.gradle.org/m2/"
		}
		*/
	}
	dependencies {
		classpath 'net.minecraftforge.gradle:ForgeGradle:2.2-SNAPSHOT'
		// for cursegradle
		//classpath "gradle.plugin.com.matthewprenger:CurseGradle:1.0.7"
	}
}

plugins {
	id "com.matthewprenger.cursegradle" version "1.0.7"
	id "se.bjurr.gitchangelog.git-changelog-gradle-plugin" version "1.32"
}

// apply plugin: 'com.matthewprenger.cursegradle'
apply plugin: 'scala'

sourceSets {
	foundation;
}

apply plugin: 'net.minecraftforge.gradle.forge'

repositories {

}

dependencies {

}

ext.getBuildNumber = {
	if (System.getenv("BUILD_NUMBER") != null) return "${System.getenv("BUILD_NUMBER")}"
	else if (project.hasProperty("bambooBuildNumber")) return project.bambooBuildNumber
	else return getDate()
}

def getDate() {
	def date = new Date()
	def formattedDate = date.format('MM_dd_yyyy_HH_mm_ss')
	return formattedDate
}

group = "${org}.${groupName}"

// java version
sourceCompatibility = 1.7
targetCompatibility = 1.7
// end java version

minecraft {
	version = "${version_minecraft}-${version_forge}${version_forge_b}"
	runDir = "run"
	mappings = "${version_mcp}"

	replace "required-after:Forge", "required-after:Forge@[${version_forge},)"
	replace "@MOD_VERSION@", "${version_major}.${version_minor}.${version_patch}"
}

def getBranch() {
	if (project.hasProperty("GIT_BRANCH"))
		return "${GIT_BRANCH}"
	else {
		def proc = "git rev-parse --abbrev-ref HEAD".execute()
		proc.waitFor()
		return proc.text.trim()
	}
}

def createVersion() {
	def branch = getBranch()
	println("Building on branch " + branch)
	def version = "${version_major}.${version_minor}.${version_patch}"
	if (project.hasProperty("build_type")) {
		if (build_type == "dev") version += "." + getBuildNumber()
	} else if (!branch.startsWith("master"))
		version += "." + getBuildNumber()
	println("Bulding with version " + version)
	return version
}

archivesBaseName = "${archiveName}-${project.minecraft.version}"
version = createVersion()

sourceSets {
	foundation.compileClasspath += api.compileClasspath
	foundation.compileClasspath += api.output;
	main.compileClasspath += foundation.compileClasspath;
	main.compileClasspath += foundation.output;
}

jar {
	from sourceSets.api.output;
	from sourceSets.foundation.output;
	from sourceSets.main.output;
}

task sourcesJar(type: Jar) {
	from sourceSets.api.scala;
	from sourceSets.foundation.scala;
	from sourceSets.main.scala;
	classifier = 'sources'
}

tasks.build.dependsOn sourcesJar

processResources {
	inputs.property "version", project.version
	inputs.property "mcversion", project.minecraft.version

	from(sourceSets.main.resources.srcDirs) {
		include 'mcmod.info'
		expand 'version': project.version, 'mcversion': project.minecraft.version
	}

	from(sourceSets.main.resources.srcDirs) {
		exclude 'mcmod.info'
	}

}

apply plugin: 'maven'
apply plugin: 'maven-publish'

uploadArchives {
	repositories {
		// official DDD maven stuffs
		if (project.hasProperty("dddUser") && project.hasProperty("dddPass")) {
			mavenDeployer {
				repository(url: "http://doubledoordev.net:8082/artifactory/mods") {
					authentication(userName: dddUser, password: dddPass)
				}
				pom {
					groupId = project.group
					version = project.version
					artifactId = "${archiveName}"
					project {
						name project.archivesBaseName
						packaging 'jar'
						description '${gitConfig.gitName}'
						url 'https://github.com/TheTemportalist/${gitConfig.gitName}'

						scm {
							url 'https://github.com/TheTemportalist/${gitConfig.gitName}'
							connection 'scm:git:git://github.com/TheTemportalist/${gitConfig.gitName}.git'
							developerConnection 'scm:git:git@github.com:TheTemportalist/${gitConfig.gitName}.git'
						}

						issueManagement {
							system 'github'
							url 'https://github.com/TheTemportalist/${gitConfig.gitName}/issues'
						}

						licenses {
							license {
								name '${gitConfig.license}'
								url 'https://github.com/TheTemportalist/${gitConfig.gitName}/blob/master/LICENSE'
								distribution 'repo'
							}
						}

						developers {
							developer {
								id 'TheTemportalist'
								name 'TheTemportalist'
								roles { role 'developer' }
							}
						}
					}
				}
			}
		}
	}
}

curseforge {
	if (project.hasProperty("tempCurseAPI"))
		apiKey = tempCurseAPI
	project {
		id = curseID
		releaseType = curseBuildType
		changelog = file('changelog.html')
		changelogType = 'html'
		addGameVersion version_minecraft
		addArtifact sourcesJar
	}
}

task makeChangelog(type: se.bjurr.gitchangelog.plugin.gradle.GitChangelogTask) {
	filePath = "changelog.html"
	untaggedName = "${project.version}"
	fromCommit = "dcb26de2989a86e8ccc6f00f6b213302c28cfe35"
	toRef = "HEAD"
	templateContent = file('changelog.min.html').getText("UTF-8")
}

afterEvaluate {
	tasks["curseforge${curseID}"].dependsOn.add(makeChangelog)
}

task release { // Done locally to execute a release on CI to curseforge
	doLast {

		def branch = getBranch()
		def version = "${version_major}.${version_minor}.${version_patch}"

		/** Tag with version */

		("git tag " + version).execute().waitFor()

		/** Push to BRANCH */

		("git push -u origin " + branch + " --tags").execute().waitFor()

		/** Merge current branch with master */

		"git checkout master".execute().waitFor()
		("git merge " + branch).execute().waitFor()

		/** Push with content AND tags */

		"git push -u origin master --tags".execute().waitFor()

		/** Checkout BRANCH */

		("git checkout " + branch).execute().waitFor()

	}
}
